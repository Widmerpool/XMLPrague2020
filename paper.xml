<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="resources/css/paper.css"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0">
	<info>
		<title>XSLT Earley: First Steps to a Declarative Parser Generator</title>
		<author>
			<personname>Tomos Hillman</personname>
			<email>tom@expertml.com</email>
			<uri>www.expertml.com</uri>
			<personblurb>
				<para>Tomos Hillman is the founder and principle of eXpertML Ltd, a consultancy specialising in XML, XSLT, XQuery and related technologies, particularly in the field of digital publishing, quality analysis, and transformation.</para>
				<para>Tom has given training courses to various institutions including publishers, universities and the UN, as well as being a regular faculty member at the prestigious XML Summer School in Oxford, and one of the founding members of the Markup UK committee.</para>
				<para>Originally from Wales, he now lives with his family in Yorkshire. Tom doesn't like to conform to stereotypes, but a deep love of Star Wars, table top games, fiction and animation sometimes make this hard.</para>
			</personblurb>
			<affiliation>
				<orgname>eXpertML Ltd</orgname>
			</affiliation>
		</author>
		<keywordset>
			<keyword>XSLT 3.0</keyword>
			<keyword>Earley</keyword>
			<keyword>Invisible XML</keyword>
		</keywordset>
		<abstract>
			<para>Invisible XML (<citation>Pemberton 2013</citation>) is a method for taking any structured
        text which can be parsed using a grammar, and treating it as XML. It means that the XML
        technology stack can be leveraged outside of XML structures.</para>
			<para>To be useful in XSLT transforms, a grammar based parser in XSLT is required.
				Parser-generators that provide XSLT parsers are available, but do not create parsers
				that work in the XSLT programming idiom, and can not parse ambiguous
				grammars.</para>
			<para>An interpretation of the Earley (<citation>Earley 1970</citation>) parsing algorithm may
        solve both of these problems: an Earley parser can parse any context-independent grammar,
        including any which may be ambiguous; it has also been suggested that the "Earley items"
        created as part of a parse operation can be reconfigured into a tree structure
          (<citation>Sperberg-McQueen 2017</citation>), which naturally lends itself to processing
        with XSLT.</para>
			<para>This paper attempts to lay the ground-work for producing a parser generator which creates XSLT parsers for given grammars. Examples from previous papers on the topic will be used to manually create both an XML representation of the grammar, and the desired tree structure of Earley items. In turn, these should inform what an XSLT parser for that grammar should look like.</para>
			<para>Finally the paper will discuss how the resulting parser can be abstracted and extended to parse using an arbitrary grammar, use other grammar languages, and create an XSLT parser-generator.</para>
		</abstract>
	</info>
	<note>
		<title>Note for reviewers</title>
		<para>This paper is a (somewhat last minute) work in progress, and may be read as an extended
      abstract, rather than an incomplete paper (although the latter description is certainly
      accurate)!</para>
	</note>
	<section>
		<title>Introduction</title>
    <para>This paper is a continuation of the works in papers on invisible XML and the Earley
      parser, particularly <citation>Pemberton 2016</citation> and <citation>Sperberg-McQueen
        2017</citation>.  It attempts to demonstrate an implementation of the Earley alogorithm
        (<citation>Earley 1970</citation>) - or something very close to it - using the declarative
      programming idiom of XSLT rather than its traditional, procedural form.</para>
    <para> The proof of concept that the paper aims to introduce is limited to a single pre-defined
      grammar; however it is hoped that this will form a groundwork for producing parsers and parser
      generators which can not only use any grammar, but grammars formed using a range of grammar
      languages, such as BNF and EBNF.</para>
		<section>
			<title>XSLT parsers: why we should use them</title>
		</section>
    <section/>
		<section>
			<title>LL1 parsers: why we shouldn't use them</title>
			<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
		</section>
		<section>
			<title>The declarative idiom: writing extensible parsers</title>
			<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
		</section>
		<section>
			<title>The Earley Parser</title>
			<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
		</section>
	</section>
	<section>
		<title>Methodology</title>
		<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
    <section>
      <title>Define a Grammar represented in XML</title>
      <para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
    </section>
    <section>
      <title>Define the desired parsed output</title>
    </section>
    <section>
      <title>Determine the Earley objects</title>
    </section>
    <section>
      <title>Determine the Earley Tree</title>
      <para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
    </section>
    <section>
      <title>The XSLT algorithm</title>
    </section>
	</section>
	<section>
		<title>Conclusions</title>
		<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
	</section>
	<section>
		<title>Future Work</title>
		<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
	</section>

	<bibliography xml:id="references">

		<bibliomixed xml:id="Earley1970" xreflabel="Earley 1970">Earley, Jay (1970), <title>An efficient context-free parsing algorithm</title>, Communications of the ACM 13 (2): 94-102, DOI: <biblioid class="doi">10.1145/362007.362035</biblioid>
		</bibliomixed>
		
		<bibliomixed xml:id="Pemberton2013" xreflabel="Pemberton 2013">Pemberton, Steven (2013), <title>Invisible XML</title>, Presented at Balisage: The Markup Conference 2013, Montréal, Canada, August 6 - 9, 2013. In <emphasis> Proceedings of Balisage: The Markup Conference 2013. </emphasis> Balisage Series on Markup Technologies, vol. 10 (2013). DOI: <biblioid class="doi">10.4242/BalisageVol10.Pemberton01</biblioid> . </bibliomixed>
		
		<bibliomixed xml:id="Pemberton2016" xreflabel="Pemberton 2016">Pemberton, Steven (2016), <title>Parse Earley, Parse Often</title>.  In Proc. XML London 2016, University College London, June 4-5, pp.120-126.  DOI: <biblioid class="doi">10.14337/XMLLondon16.Pemberton01</biblioid></bibliomixed>
		
		<bibliomixed xml:id="Kosek2017" xreflabel="Kosek 2017">Kosek, Jirka (2017) <title>Improving validation of structured text</title>. In Proc. XML London 2017, University College London, June 11–12, pp.56–67. DOI: <biblioid class="doi">10.14337/XMLLondon17.Kosek01</biblioid> .</bibliomixed>

	<bibliomixed xml:id="Sperberg-McQueen2017" xreflabel="Sperberg-McQueen 2017">Sperberg-McQueen, C. M (2017). <title>Translating imperative algorithms into declarative, functional terms: towards Earley parsing in XSLT and XQuery.</title> Presented at Balisage: The Markup Conference 2017, Washington, DC, August 1 - 4, 2017. In Proceedings of Balisage: The Markup Conference 2017. Balisage Series on Markup Technologies, vol. 19.  DOI:  <biblioid class="doi">10.4242/BalisageVol19.Sperberg-McQueen01</biblioid>.</bibliomixed>
		
	</bibliography>
	
	<appendix>
		<title>Code Listings</title>
		<example>
			<title>Grammar (iXML)</title>
			<programlisting>program: block.
block: "{", statements, "}".
statements: statement, ";", statements; empty.
statement: if statement; while statement; assignment; call; block.
if statement: "if", condition, "then", statement, else-option.
else-option: "else", statement; empty.
empty: .
while statement: "while", condition, "do", statement.
assignment: variable, "=", expression.
variable: identifier.
call: identifier, "(", parameters, ")".</programlisting>
		</example>
		<example>
			<title>Grammar (iXML as XML format)</title>
			<programlisting>&lt;ixml>
  &lt;rule name="program">: 
    &lt;alt>
      &lt;nonterminal name="block"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="block">:
    &lt;alt>
      &lt;literal dstring="{"/>,
      &lt;nonterminal name="statements"/>,
      &lt;literal dstring="}"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="statements">:
    &lt;alt>
      &lt;nonterminal name="statement"/>,
      &lt;literal dstring=";"/>,
      &lt;nonterminal name="statements"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="empty"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="statement">:
    &lt;alt>
      &lt;nonterminal name="if statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="while statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="assignment"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="call"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="block"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="if statement">:
    &lt;alt>
      &lt;literal dstring="if"/>,
      &lt;nonterminal name="condition"/>,
      &lt;literal dstring="then"/>,
      &lt;nonterminal name="statement"/>,
      &lt;nonterminal name="else-option"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="else-option">:
    &lt;alt>
      &lt;literal dstring="else"/>,
      &lt;nonterminal name="statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="empty"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="empty">:
    &lt;alt/>.
  &lt;/rule>
  &lt;rule name="while statement">:
    &lt;alt>
      &lt;literal dstring="while"/>,
      &lt;nonterminal name="condition"/>,
      &lt;literal dstring="do"/>,
      &lt;nonterminal name="statement"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="assignment">:
    &lt;alt>
      &lt;nonterminal name="variable"/>,
      &lt;literal dstring="="/>,
      &lt;nonterminal name="expression"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="variable">:
    &lt;alt>
      &lt;nonterminal name="identifier"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="call">:
    &lt;alt>
      &lt;nonterminal name="identifier"/>,
      &lt;literal dstring="("/>,
      &lt;nonterminal name="parameters"/>,
      &lt;literal dstring=")"/>
    &lt;/alt>.
  &lt;/rule>
&lt;/ixml></programlisting>
		</example>
		<example>
			<title>Desired Output</title>
			<programlisting>&lt;program>
   &lt;block>{
      &lt;statements>
         &lt;statement>
            &lt;assignment>
               &lt;variable>
                  &lt;identifier>a&lt;/identifier>
               &lt;/variable>
               =
               &lt;expression>
                  &lt;number>0&lt;/number>
               &lt;/expression>
            &lt;/assignment>
         &lt;/statement>;
         &lt;statements>
            &lt;empty>&lt;/empty>
         &lt;/statements>
      &lt;/statements>
   }&lt;/block>
&lt;/program></programlisting>
		</example>
		<example>
			<title>Earley Items</title>
			<programlisting/>
		</example>
		<example>
			<title>Earley Tree</title>
			<programlisting/>
		</example>
	</appendix>

</article>
